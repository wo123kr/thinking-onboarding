{"ast":null,"code":"var _jsxFileName = \"/Users/jegaljin-u/workspace/thinking-guide/src/components/TowerDefenseGame.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const TowerDefenseGame = ({\n  onAction,\n  playerStats,\n  setPlayerStats,\n  currentUser\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const gameLoopRef = useRef();\n\n  // Game path (enemy route)\n  const gamePath = [{\n    x: 0,\n    y: 200\n  }, {\n    x: 150,\n    y: 200\n  }, {\n    x: 150,\n    y: 100\n  }, {\n    x: 300,\n    y: 100\n  }, {\n    x: 300,\n    y: 300\n  }, {\n    x: 450,\n    y: 300\n  }, {\n    x: 450,\n    y: 150\n  }, {\n    x: 600,\n    y: 150\n  }];\n\n  // Game state\n  const [gameState, setGameState] = useState({\n    wave: 1,\n    lives: 20,\n    gold: 500,\n    score: 0,\n    waveProgress: 0,\n    gameStatus: 'playing',\n    selectedTowerType: null\n  });\n  const [towers, setTowers] = useState([]);\n  const [enemies, setEnemies] = useState([]);\n  const [projectiles, setProjectiles] = useState([]);\n  const [frameCount, setFrameCount] = useState(0);\n  const [nextEnemySpawn, setNextEnemySpawn] = useState(0);\n\n  // Tower types configuration\n  const towerTypes = {\n    archer: {\n      cost: 100,\n      damage: 25,\n      range: 120,\n      speed: 30,\n      color: '#8B4513'\n    },\n    cannon: {\n      cost: 200,\n      damage: 60,\n      range: 100,\n      speed: 60,\n      color: '#696969'\n    },\n    magic: {\n      cost: 300,\n      damage: 40,\n      range: 140,\n      speed: 40,\n      color: '#9400D3'\n    },\n    ice: {\n      cost: 250,\n      damage: 20,\n      range: 110,\n      speed: 45,\n      color: '#00BFFF'\n    }\n  };\n\n  // Enemy types configuration\n  const enemyTypes = {\n    goblin: {\n      health: 80,\n      speed: 2,\n      reward: 15,\n      color: '#228B22'\n    },\n    orc: {\n      health: 150,\n      speed: 1.5,\n      reward: 25,\n      color: '#8B4513'\n    },\n    troll: {\n      health: 300,\n      speed: 1,\n      reward: 40,\n      color: '#2F4F4F'\n    },\n    dragon: {\n      health: 500,\n      speed: 0.8,\n      reward: 80,\n      color: '#DC143C'\n    }\n  };\n\n  // Prevent default keyboard actions\n  const handleKeyDown = useCallback(e => {\n    // Prevent default for game keys to avoid page scrolling\n    if (['1', '2', '3', '4', ' ', 'Enter', 'Escape'].includes(e.key)) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Handle tower selection\n      switch (e.key) {\n        case '1':\n          setGameState(prev => ({\n            ...prev,\n            selectedTowerType: 'archer'\n          }));\n          break;\n        case '2':\n          setGameState(prev => ({\n            ...prev,\n            selectedTowerType: 'cannon'\n          }));\n          break;\n        case '3':\n          setGameState(prev => ({\n            ...prev,\n            selectedTowerType: 'magic'\n          }));\n          break;\n        case '4':\n          setGameState(prev => ({\n            ...prev,\n            selectedTowerType: 'ice'\n          }));\n          break;\n        case ' ':\n          startNextWave();\n          break;\n        case 'Escape':\n          setGameState(prev => ({\n            ...prev,\n            selectedTowerType: null\n          }));\n          break;\n      }\n    }\n  }, []);\n\n  // Canvas click handler\n  const handleCanvasClick = useCallback(e => {\n    const canvas = canvasRef.current;\n    if (!canvas || !gameState.selectedTowerType) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    // Check if click is valid tower placement\n    if (canPlaceTower(x, y)) {\n      placeTower(x, y, gameState.selectedTowerType);\n    }\n  }, [gameState.selectedTowerType]);\n  const canPlaceTower = (x, y) => {\n    // Check if too close to path\n    for (const point of gamePath) {\n      const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);\n      if (distance < 40) return false;\n    }\n\n    // Check if too close to existing towers\n    for (const tower of towers) {\n      const distance = Math.sqrt((x - tower.x) ** 2 + (y - tower.y) ** 2);\n      if (distance < 50) return false;\n    }\n    return true;\n  };\n  const placeTower = (x, y, type) => {\n    const towerConfig = towerTypes[type];\n    if (gameState.gold < towerConfig.cost) {\n      onAction('tower_placement_failed', {\n        reason: 'insufficient_gold',\n        required_gold: towerConfig.cost,\n        current_gold: gameState.gold,\n        tower_type: type\n      });\n      return;\n    }\n    const newTower = {\n      id: `tower_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,\n      x,\n      y,\n      type,\n      level: 1,\n      damage: towerConfig.damage,\n      range: towerConfig.range,\n      attackSpeed: towerConfig.speed,\n      lastAttack: 0,\n      cost: towerConfig.cost,\n      kills: 0\n    };\n    setTowers(prev => [...prev, newTower]);\n    setGameState(prev => ({\n      ...prev,\n      gold: prev.gold - towerConfig.cost,\n      selectedTowerType: null\n    }));\n    setPlayerStats(prev => ({\n      ...prev,\n      gold: gameState.gold - towerConfig.cost\n    }));\n    onAction('tower_placed', {\n      tower_type: type,\n      tower_id: newTower.id,\n      position_x: x,\n      position_y: y,\n      cost: towerConfig.cost,\n      remaining_gold: gameState.gold - towerConfig.cost,\n      wave: gameState.wave\n    });\n  };\n  const startNextWave = () => {\n    if (gameState.waveProgress > 0) return; // Wave already in progress\n\n    setGameState(prev => ({\n      ...prev,\n      waveProgress: 1\n    }));\n    setNextEnemySpawn(frameCount + 60); // Start spawning in 1 second\n\n    onAction('wave_started', {\n      wave_number: gameState.wave,\n      current_gold: gameState.gold,\n      current_lives: gameState.lives,\n      towers_count: towers.length\n    });\n  };\n  const spawnEnemy = () => {\n    const waveTypes = ['goblin', 'orc', 'troll', 'dragon'];\n    const typeIndex = Math.min(Math.floor(gameState.wave / 2), waveTypes.length - 1);\n    const enemyType = waveTypes[Math.floor(Math.random() * (typeIndex + 1))];\n    const enemyConfig = enemyTypes[enemyType];\n    const newEnemy = {\n      id: `enemy_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,\n      x: gamePath[0].x,\n      y: gamePath[0].y,\n      health: enemyConfig.health + (gameState.wave - 1) * 20,\n      maxHealth: enemyConfig.health + (gameState.wave - 1) * 20,\n      speed: enemyConfig.speed,\n      type: enemyType,\n      reward: enemyConfig.reward + gameState.wave * 2,\n      pathIndex: 0,\n      alive: true,\n      effects: []\n    };\n    setEnemies(prev => [...prev, newEnemy]);\n    onAction('enemy_spawned', {\n      enemy_type: enemyType,\n      enemy_id: newEnemy.id,\n      wave: gameState.wave,\n      enemy_health: newEnemy.health,\n      enemy_reward: newEnemy.reward\n    });\n  };\n  const updateEnemies = useCallback(() => {\n    setEnemies(prev => prev.map(enemy => {\n      if (!enemy.alive) return enemy;\n\n      // Move along path\n      const currentTarget = gamePath[enemy.pathIndex + 1];\n      if (currentTarget) {\n        const dx = currentTarget.x - enemy.x;\n        const dy = currentTarget.y - enemy.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance < 5) {\n          enemy.pathIndex++;\n          if (enemy.pathIndex >= gamePath.length - 1) {\n            // Enemy reached the end\n            setGameState(prevState => ({\n              ...prevState,\n              lives: prevState.lives - 1\n            }));\n            onAction('enemy_reached_end', {\n              enemy_type: enemy.type,\n              enemy_id: enemy.id,\n              lives_lost: 1,\n              remaining_lives: gameState.lives - 1,\n              wave: gameState.wave\n            });\n            return {\n              ...enemy,\n              alive: false\n            };\n          }\n        } else {\n          const moveX = dx / distance * enemy.speed;\n          const moveY = dy / distance * enemy.speed;\n          enemy.x += moveX;\n          enemy.y += moveY;\n        }\n      }\n      return enemy;\n    }).filter(enemy => enemy.alive || enemy.pathIndex < gamePath.length - 1));\n  }, [gameState.lives, gameState.wave, onAction]);\n  const updateTowers = useCallback(() => {\n    towers.forEach(tower => {\n      if (frameCount - tower.lastAttack < tower.attackSpeed) return;\n\n      // Find target\n      const enemiesInRange = enemies.filter(enemy => {\n        if (!enemy.alive) return false;\n        const distance = Math.sqrt((enemy.x - tower.x) ** 2 + (enemy.y - tower.y) ** 2);\n        return distance <= tower.range;\n      });\n      if (enemiesInRange.length > 0) {\n        // Target the enemy furthest along the path\n        const target = enemiesInRange.reduce((best, current) => current.pathIndex > best.pathIndex ? current : best);\n\n        // Create projectile\n        const newProjectile = {\n          id: `proj_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,\n          x: tower.x,\n          y: tower.y,\n          targetX: target.x,\n          targetY: target.y,\n          speed: 8,\n          damage: tower.damage,\n          type: tower.type,\n          towerId: tower.id\n        };\n        setProjectiles(prev => [...prev, newProjectile]);\n        tower.lastAttack = frameCount;\n        onAction('tower_attack', {\n          tower_type: tower.type,\n          tower_id: tower.id,\n          target_enemy_id: target.id,\n          target_enemy_type: target.type,\n          damage: tower.damage,\n          wave: gameState.wave\n        });\n      }\n    });\n  }, [towers, enemies, frameCount, gameState.wave, onAction]);\n  const updateProjectiles = useCallback(() => {\n    setProjectiles(prev => prev.filter(proj => {\n      const dx = proj.targetX - proj.x;\n      const dy = proj.targetY - proj.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      if (distance < 5) {\n        // Hit target - find enemy and damage\n        setEnemies(prevEnemies => prevEnemies.map(enemy => {\n          const enemyDistance = Math.sqrt((enemy.x - proj.targetX) ** 2 + (enemy.y - proj.targetY) ** 2);\n          if (enemyDistance < 30 && enemy.alive) {\n            const newHealth = Math.max(0, enemy.health - proj.damage);\n            const killed = newHealth <= 0;\n            if (killed) {\n              // Enemy killed\n              setGameState(prevState => ({\n                ...prevState,\n                gold: prevState.gold + enemy.reward,\n                score: prevState.score + enemy.reward * 10\n              }));\n              setPlayerStats(prev => ({\n                ...prev,\n                gold: gameState.gold + enemy.reward,\n                experience: prev.experience + enemy.reward\n              }));\n\n              // Update tower kill count\n              setTowers(prevTowers => prevTowers.map(tower => tower.id === proj.towerId ? {\n                ...tower,\n                kills: tower.kills + 1\n              } : tower));\n              onAction('enemy_defeated', {\n                enemy_type: enemy.type,\n                enemy_id: enemy.id,\n                tower_type: proj.type,\n                tower_id: proj.towerId,\n                damage_dealt: proj.damage,\n                gold_gained: enemy.reward,\n                exp_gained: enemy.reward,\n                wave: gameState.wave\n              });\n              return {\n                ...enemy,\n                health: 0,\n                alive: false\n              };\n            } else {\n              onAction('enemy_damaged', {\n                enemy_type: enemy.type,\n                enemy_id: enemy.id,\n                tower_type: proj.type,\n                damage_dealt: proj.damage,\n                enemy_health_remaining: newHealth,\n                wave: gameState.wave\n              });\n              return {\n                ...enemy,\n                health: newHealth\n              };\n            }\n          }\n          return enemy;\n        }));\n        return false; // Remove projectile\n      }\n\n      // Move projectile\n      const moveX = dx / distance * proj.speed;\n      const moveY = dy / distance * proj.speed;\n      proj.x += moveX;\n      proj.y += moveY;\n      return true; // Keep projectile\n    }));\n  }, [gameState.gold, gameState.wave, onAction, setPlayerStats]);\n\n  // Wave management\n  useEffect(() => {\n    if (gameState.waveProgress > 0 && frameCount >= nextEnemySpawn) {\n      const enemiesThisWave = 5 + gameState.wave * 2;\n      const spawnedCount = enemies.filter(e => e.alive).length;\n      if (spawnedCount < enemiesThisWave) {\n        spawnEnemy();\n        setNextEnemySpawn(frameCount + 45 - Math.min(gameState.wave, 30)); // Faster spawning as waves progress\n      } else if (enemies.filter(e => e.alive).length === 0) {\n        // Wave complete\n        setGameState(prev => ({\n          ...prev,\n          wave: prev.wave + 1,\n          waveProgress: 0,\n          gold: prev.gold + 50 + prev.wave * 10 // Wave completion bonus\n        }));\n        onAction('wave_completed', {\n          wave_number: gameState.wave,\n          bonus_gold: 50 + gameState.wave * 10,\n          total_gold: gameState.gold + 50 + gameState.wave * 10,\n          score: gameState.score,\n          towers_count: towers.length\n        });\n      }\n    }\n  }, [frameCount, nextEnemySpawn, gameState.waveProgress, gameState.wave, enemies, gameState.gold, gameState.score, towers.length, onAction]);\n\n  // Game over check\n  useEffect(() => {\n    if (gameState.lives <= 0) {\n      setGameState(prev => ({\n        ...prev,\n        gameStatus: 'gameOver'\n      }));\n      onAction('game_over', {\n        final_wave: gameState.wave,\n        final_score: gameState.score,\n        towers_built: towers.length,\n        total_kills: towers.reduce((sum, tower) => sum + tower.kills, 0)\n      });\n    }\n  }, [gameState.lives, gameState.wave, gameState.score, towers, onAction]);\n\n  // Drawing functions\n  const drawPath = ctx => {\n    ctx.strokeStyle = '#8B4513';\n    ctx.lineWidth = 30;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ctx.beginPath();\n    ctx.moveTo(gamePath[0].x, gamePath[0].y);\n    gamePath.slice(1).forEach(point => {\n      ctx.lineTo(point.x, point.y);\n    });\n    ctx.stroke();\n\n    // Path decorations\n    ctx.strokeStyle = '#DEB887';\n    ctx.lineWidth = 20;\n    ctx.beginPath();\n    ctx.moveTo(gamePath[0].x, gamePath[0].y);\n    gamePath.slice(1).forEach(point => {\n      ctx.lineTo(point.x, point.y);\n    });\n    ctx.stroke();\n  };\n  const drawTower = (ctx, tower) => {\n    const config = towerTypes[tower.type];\n\n    // Tower base\n    ctx.fillStyle = '#696969';\n    ctx.beginPath();\n    ctx.arc(tower.x, tower.y, 20, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Tower top\n    ctx.fillStyle = config.color;\n    ctx.beginPath();\n    ctx.arc(tower.x, tower.y, 15, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Tower details based on type\n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = '12px Arial';\n    ctx.textAlign = 'center';\n    const symbols = {\n      archer: '🏹',\n      cannon: '💣',\n      magic: '✨',\n      ice: '❄️'\n    };\n    ctx.fillText(symbols[tower.type], tower.x, tower.y + 4);\n\n    // Range indicator for selected tower type\n    if (gameState.selectedTowerType === tower.type) {\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\n      ctx.lineWidth = 2;\n      ctx.setLineDash([5, 5]);\n      ctx.beginPath();\n      ctx.arc(tower.x, tower.y, tower.range, 0, 2 * Math.PI);\n      ctx.stroke();\n      ctx.setLineDash([]);\n    }\n\n    // Kill count\n    if (tower.kills > 0) {\n      ctx.fillStyle = '#FFD700';\n      ctx.font = '10px Arial';\n      ctx.fillText(tower.kills.toString(), tower.x, tower.y - 25);\n    }\n  };\n  const drawEnemy = (ctx, enemy) => {\n    if (!enemy.alive) return;\n    const config = enemyTypes[enemy.type];\n    const size = {\n      goblin: 12,\n      orc: 16,\n      troll: 20,\n      dragon: 24\n    }[enemy.type];\n\n    // Enemy body\n    ctx.fillStyle = config.color;\n    ctx.beginPath();\n    ctx.arc(enemy.x, enemy.y, size, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Enemy details\n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'center';\n    const symbols = {\n      goblin: '👹',\n      orc: '🗡️',\n      troll: '🏔️',\n      dragon: '🐉'\n    };\n    ctx.fillText(symbols[enemy.type], enemy.x, enemy.y + 4);\n\n    // Health bar\n    const barWidth = size * 2;\n    const barHeight = 4;\n    const healthPercent = enemy.health / enemy.maxHealth;\n    ctx.fillStyle = '#FF0000';\n    ctx.fillRect(enemy.x - barWidth / 2, enemy.y - size - 10, barWidth, barHeight);\n    ctx.fillStyle = '#00FF00';\n    ctx.fillRect(enemy.x - barWidth / 2, enemy.y - size - 10, barWidth * healthPercent, barHeight);\n  };\n  const drawProjectile = (ctx, projectile) => {\n    const colors = {\n      archer: '#8B4513',\n      cannon: '#000000',\n      magic: '#9400D3',\n      ice: '#00BFFF'\n    };\n    ctx.fillStyle = colors[projectile.type];\n    ctx.beginPath();\n    ctx.arc(projectile.x, projectile.y, 4, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Trail effect\n    ctx.fillStyle = colors[projectile.type] + '80';\n    ctx.beginPath();\n    ctx.arc(projectile.x - 2, projectile.y - 2, 2, 0, 2 * Math.PI);\n    ctx.fill();\n  };\n  const drawUI = (ctx, canvas) => {\n    // Game stats panel\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n    ctx.fillRect(0, 0, canvas.width, 60);\n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = '16px Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Wave: ${gameState.wave}`, 10, 25);\n    ctx.fillText(`Lives: ${gameState.lives}`, 10, 45);\n    ctx.fillText(`Gold: ${gameState.gold}`, 120, 25);\n    ctx.fillText(`Score: ${gameState.score}`, 120, 45);\n\n    // Tower selection panel\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n    ctx.fillRect(0, canvas.height - 80, canvas.width, 80);\n    const towerButtons = [{\n      type: 'archer',\n      x: 50,\n      key: '1'\n    }, {\n      type: 'cannon',\n      x: 150,\n      key: '2'\n    }, {\n      type: 'magic',\n      x: 250,\n      key: '3'\n    }, {\n      type: 'ice',\n      x: 350,\n      key: '4'\n    }];\n    towerButtons.forEach(button => {\n      const config = towerTypes[button.type];\n      const isSelected = gameState.selectedTowerType === button.type;\n      const canAfford = gameState.gold >= config.cost;\n\n      // Button background\n      ctx.fillStyle = isSelected ? 'rgba(255, 255, 0, 0.5)' : canAfford ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 0, 0, 0.2)';\n      ctx.fillRect(button.x - 25, canvas.height - 70, 50, 60);\n\n      // Tower icon\n      ctx.fillStyle = config.color;\n      ctx.beginPath();\n      ctx.arc(button.x, canvas.height - 55, 12, 0, 2 * Math.PI);\n      ctx.fill();\n\n      // Tower info\n      ctx.fillStyle = canAfford ? '#FFFFFF' : '#FF6666';\n      ctx.font = '12px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(`${button.key}: $${config.cost}`, button.x, canvas.height - 20);\n      ctx.fillText(button.type.toUpperCase(), button.x, canvas.height - 8);\n    });\n\n    // Instructions\n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'right';\n    ctx.fillText('SPACE: Next Wave', canvas.width - 10, canvas.height - 45);\n    ctx.fillText('ESC: Cancel', canvas.width - 10, canvas.height - 25);\n    ctx.fillText('1-4: Select Tower', canvas.width - 10, canvas.height - 5);\n\n    // Wave progress\n    if (gameState.waveProgress > 0) {\n      ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';\n      ctx.font = '20px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText('WAVE IN PROGRESS', canvas.width / 2, 35);\n    }\n\n    // Game over screen\n    if (gameState.gameStatus === 'gameOver') {\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      ctx.fillStyle = '#FF0000';\n      ctx.font = '32px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);\n      ctx.fillStyle = '#FFFFFF';\n      ctx.font = '18px Arial';\n      ctx.fillText(`Final Wave: ${gameState.wave}`, canvas.width / 2, canvas.height / 2);\n      ctx.fillText(`Final Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 30);\n    }\n  };\n  const draw = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Clear canvas with background\n    ctx.fillStyle = '#1a4c2e';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Draw game elements\n    drawPath(ctx);\n    towers.forEach(tower => drawTower(ctx, tower));\n    enemies.forEach(enemy => drawEnemy(ctx, enemy));\n    projectiles.forEach(proj => drawProjectile(ctx, proj));\n    drawUI(ctx, canvas);\n\n    // Show placement preview\n    if (gameState.selectedTowerType && canvas) {\n      const rect = canvas.getBoundingClientRect();\n      // This would need mouse position tracking for preview\n    }\n  }, [towers, enemies, projectiles, gameState]);\n\n  // Game loop\n  useEffect(() => {\n    const gameLoop = () => {\n      updateEnemies();\n      updateTowers();\n      updateProjectiles();\n      draw();\n      setFrameCount(prev => prev + 1);\n      gameLoopRef.current = requestAnimationFrame(gameLoop);\n    };\n    gameLoopRef.current = requestAnimationFrame(gameLoop);\n    return () => {\n      if (gameLoopRef.current) {\n        cancelAnimationFrame(gameLoopRef.current);\n      }\n    };\n  }, [updateEnemies, updateTowers, updateProjectiles, draw]);\n\n  // Event listeners\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown);\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [handleKeyDown]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      display: 'flex',\n      flexDirection: 'column',\n      alignItems: 'center',\n      background: '#0f2419',\n      borderRadius: '12px',\n      padding: '16px',\n      border: '2px solid #2d5016'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: 600,\n      height: 400,\n      style: {\n        border: '2px solid #4a6741',\n        borderRadius: '8px',\n        background: '#1a4c2e',\n        cursor: gameState.selectedTowerType ? 'crosshair' : 'default'\n      },\n      onClick: handleCanvasClick,\n      tabIndex: 0\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 739,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginTop: '12px',\n        color: '#ffffff',\n        fontSize: '14px',\n        textAlign: 'center',\n        maxWidth: '600px'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"\\uD83C\\uDFF0 \", /*#__PURE__*/_jsxDEV(\"strong\", {\n          children: \"Tower Defense\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 760,\n          columnNumber: 15\n        }, this), \" - \\uD0A4\\uBCF4\\uB4DC 1-4\\uB85C \\uD0C0\\uC6CC \\uC120\\uD0DD, \\uD074\\uB9AD\\uC73C\\uB85C \\uBC30\\uCE58, Space\\uB85C \\uC6E8\\uC774\\uBE0C \\uC2DC\\uC791!\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 760,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"\\uC801\\uB4E4\\uC774 \\uB05D\\uAE4C\\uC9C0 \\uAC00\\uC9C0 \\uBABB\\uD558\\uB3C4\\uB85D \\uD0C0\\uC6CC\\uB97C \\uBC30\\uCE58\\uD574\\uC11C \\uB9C9\\uC544\\uBCF4\\uC138\\uC694!\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 761,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 753,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 730,\n    columnNumber: 5\n  }, this);\n};\n_s(TowerDefenseGame, \"7TzvgSnv520YPHTL4tGIL1iIXC4=\");\n_c = TowerDefenseGame;\nvar _c;\n$RefreshReg$(_c, \"TowerDefenseGame\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","jsxDEV","_jsxDEV","TowerDefenseGame","onAction","playerStats","setPlayerStats","currentUser","_s","canvasRef","gameLoopRef","gamePath","x","y","gameState","setGameState","wave","lives","gold","score","waveProgress","gameStatus","selectedTowerType","towers","setTowers","enemies","setEnemies","projectiles","setProjectiles","frameCount","setFrameCount","nextEnemySpawn","setNextEnemySpawn","towerTypes","archer","cost","damage","range","speed","color","cannon","magic","ice","enemyTypes","goblin","health","reward","orc","troll","dragon","handleKeyDown","e","includes","key","preventDefault","stopPropagation","prev","startNextWave","handleCanvasClick","canvas","current","rect","getBoundingClientRect","clientX","left","clientY","top","canPlaceTower","placeTower","point","distance","Math","sqrt","tower","type","towerConfig","reason","required_gold","current_gold","tower_type","newTower","id","Date","now","random","toString","substr","level","attackSpeed","lastAttack","kills","tower_id","position_x","position_y","remaining_gold","wave_number","current_lives","towers_count","length","spawnEnemy","waveTypes","typeIndex","min","floor","enemyType","enemyConfig","newEnemy","maxHealth","pathIndex","alive","effects","enemy_type","enemy_id","enemy_health","enemy_reward","updateEnemies","map","enemy","currentTarget","dx","dy","prevState","lives_lost","remaining_lives","moveX","moveY","filter","updateTowers","forEach","enemiesInRange","target","reduce","best","newProjectile","targetX","targetY","towerId","target_enemy_id","target_enemy_type","updateProjectiles","proj","prevEnemies","enemyDistance","newHealth","max","killed","experience","prevTowers","damage_dealt","gold_gained","exp_gained","enemy_health_remaining","enemiesThisWave","spawnedCount","bonus_gold","total_gold","final_wave","final_score","towers_built","total_kills","sum","drawPath","ctx","strokeStyle","lineWidth","lineCap","lineJoin","beginPath","moveTo","slice","lineTo","stroke","drawTower","config","fillStyle","arc","PI","fill","font","textAlign","symbols","fillText","setLineDash","drawEnemy","size","barWidth","barHeight","healthPercent","fillRect","drawProjectile","projectile","colors","drawUI","width","height","towerButtons","button","isSelected","canAfford","toUpperCase","draw","getContext","gameLoop","requestAnimationFrame","cancelAnimationFrame","document","addEventListener","removeEventListener","style","display","flexDirection","alignItems","background","borderRadius","padding","border","children","ref","cursor","onClick","tabIndex","fileName","_jsxFileName","lineNumber","columnNumber","marginTop","fontSize","maxWidth","_c","$RefreshReg$"],"sources":["/Users/jegaljin-u/workspace/thinking-guide/src/components/TowerDefenseGame.tsx"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\n\ninterface GameProps {\n  onAction: (eventType: string, data: any) => void;\n  isSimulating: boolean;\n  currentAction: string | null;\n  playerStats: any;\n  setPlayerStats: (stats: any) => void;\n  currentUser: any;\n}\n\ninterface Tower {\n  id: string;\n  x: number;\n  y: number;\n  type: 'archer' | 'cannon' | 'magic' | 'ice';\n  level: number;\n  damage: number;\n  range: number;\n  attackSpeed: number;\n  lastAttack: number;\n  cost: number;\n  kills: number;\n}\n\ninterface Enemy {\n  id: string;\n  x: number;\n  y: number;\n  health: number;\n  maxHealth: number;\n  speed: number;\n  type: 'goblin' | 'orc' | 'troll' | 'dragon';\n  reward: number;\n  pathIndex: number;\n  alive: boolean;\n  effects: string[];\n}\n\ninterface Projectile {\n  id: string;\n  x: number;\n  y: number;\n  targetX: number;\n  targetY: number;\n  speed: number;\n  damage: number;\n  type: string;\n  towerId: string;\n}\n\ninterface GameState {\n  wave: number;\n  lives: number;\n  gold: number;\n  score: number;\n  waveProgress: number;\n  gameStatus: 'playing' | 'paused' | 'gameOver' | 'victory';\n  selectedTowerType: Tower['type'] | null;\n}\n\nexport const TowerDefenseGame: React.FC<GameProps> = ({\n  onAction,\n  playerStats,\n  setPlayerStats,\n  currentUser\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const gameLoopRef = useRef<number>();\n  \n  // Game path (enemy route)\n  const gamePath = [\n    { x: 0, y: 200 },\n    { x: 150, y: 200 },\n    { x: 150, y: 100 },\n    { x: 300, y: 100 },\n    { x: 300, y: 300 },\n    { x: 450, y: 300 },\n    { x: 450, y: 150 },\n    { x: 600, y: 150 },\n  ];\n\n  // Game state\n  const [gameState, setGameState] = useState<GameState>({\n    wave: 1,\n    lives: 20,\n    gold: 500,\n    score: 0,\n    waveProgress: 0,\n    gameStatus: 'playing',\n    selectedTowerType: null,\n  });\n\n  const [towers, setTowers] = useState<Tower[]>([]);\n  const [enemies, setEnemies] = useState<Enemy[]>([]);\n  const [projectiles, setProjectiles] = useState<Projectile[]>([]);\n  const [frameCount, setFrameCount] = useState(0);\n  const [nextEnemySpawn, setNextEnemySpawn] = useState(0);\n\n  // Tower types configuration\n  const towerTypes = {\n    archer: { cost: 100, damage: 25, range: 120, speed: 30, color: '#8B4513' },\n    cannon: { cost: 200, damage: 60, range: 100, speed: 60, color: '#696969' },\n    magic: { cost: 300, damage: 40, range: 140, speed: 40, color: '#9400D3' },\n    ice: { cost: 250, damage: 20, range: 110, speed: 45, color: '#00BFFF' }\n  };\n\n  // Enemy types configuration\n  const enemyTypes = {\n    goblin: { health: 80, speed: 2, reward: 15, color: '#228B22' },\n    orc: { health: 150, speed: 1.5, reward: 25, color: '#8B4513' },\n    troll: { health: 300, speed: 1, reward: 40, color: '#2F4F4F' },\n    dragon: { health: 500, speed: 0.8, reward: 80, color: '#DC143C' }\n  };\n\n  // Prevent default keyboard actions\n  const handleKeyDown = useCallback((e: KeyboardEvent) => {\n    // Prevent default for game keys to avoid page scrolling\n    if (['1', '2', '3', '4', ' ', 'Enter', 'Escape'].includes(e.key)) {\n      e.preventDefault();\n      e.stopPropagation();\n      \n      // Handle tower selection\n      switch(e.key) {\n        case '1':\n          setGameState(prev => ({ ...prev, selectedTowerType: 'archer' }));\n          break;\n        case '2':\n          setGameState(prev => ({ ...prev, selectedTowerType: 'cannon' }));\n          break;\n        case '3':\n          setGameState(prev => ({ ...prev, selectedTowerType: 'magic' }));\n          break;\n        case '4':\n          setGameState(prev => ({ ...prev, selectedTowerType: 'ice' }));\n          break;\n        case ' ':\n          startNextWave();\n          break;\n        case 'Escape':\n          setGameState(prev => ({ ...prev, selectedTowerType: null }));\n          break;\n      }\n    }\n  }, []);\n\n  // Canvas click handler\n  const handleCanvasClick = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas || !gameState.selectedTowerType) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    // Check if click is valid tower placement\n    if (canPlaceTower(x, y)) {\n      placeTower(x, y, gameState.selectedTowerType);\n    }\n  }, [gameState.selectedTowerType]);\n\n  const canPlaceTower = (x: number, y: number): boolean => {\n    // Check if too close to path\n    for (const point of gamePath) {\n      const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);\n      if (distance < 40) return false;\n    }\n\n    // Check if too close to existing towers\n    for (const tower of towers) {\n      const distance = Math.sqrt((x - tower.x) ** 2 + (y - tower.y) ** 2);\n      if (distance < 50) return false;\n    }\n\n    return true;\n  };\n\n  const placeTower = (x: number, y: number, type: Tower['type']) => {\n    const towerConfig = towerTypes[type];\n    \n    if (gameState.gold < towerConfig.cost) {\n      onAction('tower_placement_failed', {\n        reason: 'insufficient_gold',\n        required_gold: towerConfig.cost,\n        current_gold: gameState.gold,\n        tower_type: type,\n      });\n      return;\n    }\n\n    const newTower: Tower = {\n      id: `tower_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,\n      x,\n      y,\n      type,\n      level: 1,\n      damage: towerConfig.damage,\n      range: towerConfig.range,\n      attackSpeed: towerConfig.speed,\n      lastAttack: 0,\n      cost: towerConfig.cost,\n      kills: 0,\n    };\n\n    setTowers(prev => [...prev, newTower]);\n    setGameState(prev => ({ \n      ...prev, \n      gold: prev.gold - towerConfig.cost,\n      selectedTowerType: null \n    }));\n\n    setPlayerStats((prev: any) => ({\n      ...prev,\n      gold: gameState.gold - towerConfig.cost,\n    }));\n\n    onAction('tower_placed', {\n      tower_type: type,\n      tower_id: newTower.id,\n      position_x: x,\n      position_y: y,\n      cost: towerConfig.cost,\n      remaining_gold: gameState.gold - towerConfig.cost,\n      wave: gameState.wave,\n    });\n  };\n\n  const startNextWave = () => {\n    if (gameState.waveProgress > 0) return; // Wave already in progress\n\n    setGameState(prev => ({ ...prev, waveProgress: 1 }));\n    setNextEnemySpawn(frameCount + 60); // Start spawning in 1 second\n\n    onAction('wave_started', {\n      wave_number: gameState.wave,\n      current_gold: gameState.gold,\n      current_lives: gameState.lives,\n      towers_count: towers.length,\n    });\n  };\n\n  const spawnEnemy = () => {\n    const waveTypes = ['goblin', 'orc', 'troll', 'dragon'] as Enemy['type'][];\n    const typeIndex = Math.min(Math.floor(gameState.wave / 2), waveTypes.length - 1);\n    const enemyType = waveTypes[Math.floor(Math.random() * (typeIndex + 1))];\n    const enemyConfig = enemyTypes[enemyType];\n\n    const newEnemy: Enemy = {\n      id: `enemy_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,\n      x: gamePath[0].x,\n      y: gamePath[0].y,\n      health: enemyConfig.health + (gameState.wave - 1) * 20,\n      maxHealth: enemyConfig.health + (gameState.wave - 1) * 20,\n      speed: enemyConfig.speed,\n      type: enemyType,\n      reward: enemyConfig.reward + gameState.wave * 2,\n      pathIndex: 0,\n      alive: true,\n      effects: [],\n    };\n\n    setEnemies(prev => [...prev, newEnemy]);\n\n    onAction('enemy_spawned', {\n      enemy_type: enemyType,\n      enemy_id: newEnemy.id,\n      wave: gameState.wave,\n      enemy_health: newEnemy.health,\n      enemy_reward: newEnemy.reward,\n    });\n  };\n\n  const updateEnemies = useCallback(() => {\n    setEnemies(prev => prev.map(enemy => {\n      if (!enemy.alive) return enemy;\n\n      // Move along path\n      const currentTarget = gamePath[enemy.pathIndex + 1];\n      if (currentTarget) {\n        const dx = currentTarget.x - enemy.x;\n        const dy = currentTarget.y - enemy.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance < 5) {\n          enemy.pathIndex++;\n          if (enemy.pathIndex >= gamePath.length - 1) {\n            // Enemy reached the end\n            setGameState(prevState => ({ \n              ...prevState, \n              lives: prevState.lives - 1 \n            }));\n\n            onAction('enemy_reached_end', {\n              enemy_type: enemy.type,\n              enemy_id: enemy.id,\n              lives_lost: 1,\n              remaining_lives: gameState.lives - 1,\n              wave: gameState.wave,\n            });\n\n            return { ...enemy, alive: false };\n          }\n        } else {\n          const moveX = (dx / distance) * enemy.speed;\n          const moveY = (dy / distance) * enemy.speed;\n          enemy.x += moveX;\n          enemy.y += moveY;\n        }\n      }\n\n      return enemy;\n    }).filter(enemy => enemy.alive || enemy.pathIndex < gamePath.length - 1));\n  }, [gameState.lives, gameState.wave, onAction]);\n\n  const updateTowers = useCallback(() => {\n    towers.forEach(tower => {\n      if (frameCount - tower.lastAttack < tower.attackSpeed) return;\n\n      // Find target\n      const enemiesInRange = enemies.filter(enemy => {\n        if (!enemy.alive) return false;\n        const distance = Math.sqrt((enemy.x - tower.x) ** 2 + (enemy.y - tower.y) ** 2);\n        return distance <= tower.range;\n      });\n\n      if (enemiesInRange.length > 0) {\n        // Target the enemy furthest along the path\n        const target = enemiesInRange.reduce((best, current) => \n          current.pathIndex > best.pathIndex ? current : best\n        );\n\n        // Create projectile\n        const newProjectile: Projectile = {\n          id: `proj_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,\n          x: tower.x,\n          y: tower.y,\n          targetX: target.x,\n          targetY: target.y,\n          speed: 8,\n          damage: tower.damage,\n          type: tower.type,\n          towerId: tower.id,\n        };\n\n        setProjectiles(prev => [...prev, newProjectile]);\n        tower.lastAttack = frameCount;\n\n        onAction('tower_attack', {\n          tower_type: tower.type,\n          tower_id: tower.id,\n          target_enemy_id: target.id,\n          target_enemy_type: target.type,\n          damage: tower.damage,\n          wave: gameState.wave,\n        });\n      }\n    });\n  }, [towers, enemies, frameCount, gameState.wave, onAction]);\n\n  const updateProjectiles = useCallback(() => {\n    setProjectiles(prev => prev.filter(proj => {\n      const dx = proj.targetX - proj.x;\n      const dy = proj.targetY - proj.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance < 5) {\n        // Hit target - find enemy and damage\n        setEnemies(prevEnemies => prevEnemies.map(enemy => {\n          const enemyDistance = Math.sqrt((enemy.x - proj.targetX) ** 2 + (enemy.y - proj.targetY) ** 2);\n          if (enemyDistance < 30 && enemy.alive) {\n            const newHealth = Math.max(0, enemy.health - proj.damage);\n            const killed = newHealth <= 0;\n\n            if (killed) {\n              // Enemy killed\n              setGameState(prevState => ({ \n                ...prevState, \n                gold: prevState.gold + enemy.reward,\n                score: prevState.score + enemy.reward * 10\n              }));\n\n              setPlayerStats((prev: any) => ({\n                ...prev,\n                gold: gameState.gold + enemy.reward,\n                experience: prev.experience + enemy.reward,\n              }));\n\n              // Update tower kill count\n              setTowers(prevTowers => prevTowers.map(tower => \n                tower.id === proj.towerId \n                  ? { ...tower, kills: tower.kills + 1 }\n                  : tower\n              ));\n\n              onAction('enemy_defeated', {\n                enemy_type: enemy.type,\n                enemy_id: enemy.id,\n                tower_type: proj.type,\n                tower_id: proj.towerId,\n                damage_dealt: proj.damage,\n                gold_gained: enemy.reward,\n                exp_gained: enemy.reward,\n                wave: gameState.wave,\n              });\n\n              return { ...enemy, health: 0, alive: false };\n            } else {\n              onAction('enemy_damaged', {\n                enemy_type: enemy.type,\n                enemy_id: enemy.id,\n                tower_type: proj.type,\n                damage_dealt: proj.damage,\n                enemy_health_remaining: newHealth,\n                wave: gameState.wave,\n              });\n\n              return { ...enemy, health: newHealth };\n            }\n          }\n          return enemy;\n        }));\n\n        return false; // Remove projectile\n      }\n\n      // Move projectile\n      const moveX = (dx / distance) * proj.speed;\n      const moveY = (dy / distance) * proj.speed;\n      proj.x += moveX;\n      proj.y += moveY;\n\n      return true; // Keep projectile\n    }));\n  }, [gameState.gold, gameState.wave, onAction, setPlayerStats]);\n\n  // Wave management\n  useEffect(() => {\n    if (gameState.waveProgress > 0 && frameCount >= nextEnemySpawn) {\n      const enemiesThisWave = 5 + gameState.wave * 2;\n      const spawnedCount = enemies.filter(e => e.alive).length;\n      \n      if (spawnedCount < enemiesThisWave) {\n        spawnEnemy();\n        setNextEnemySpawn(frameCount + 45 - Math.min(gameState.wave, 30)); // Faster spawning as waves progress\n      } else if (enemies.filter(e => e.alive).length === 0) {\n        // Wave complete\n        setGameState(prev => ({ \n          ...prev, \n          wave: prev.wave + 1, \n          waveProgress: 0,\n          gold: prev.gold + 50 + prev.wave * 10 // Wave completion bonus\n        }));\n\n        onAction('wave_completed', {\n          wave_number: gameState.wave,\n          bonus_gold: 50 + gameState.wave * 10,\n          total_gold: gameState.gold + 50 + gameState.wave * 10,\n          score: gameState.score,\n          towers_count: towers.length,\n        });\n      }\n    }\n  }, [frameCount, nextEnemySpawn, gameState.waveProgress, gameState.wave, enemies, gameState.gold, gameState.score, towers.length, onAction]);\n\n  // Game over check\n  useEffect(() => {\n    if (gameState.lives <= 0) {\n      setGameState(prev => ({ ...prev, gameStatus: 'gameOver' }));\n      \n      onAction('game_over', {\n        final_wave: gameState.wave,\n        final_score: gameState.score,\n        towers_built: towers.length,\n        total_kills: towers.reduce((sum, tower) => sum + tower.kills, 0),\n      });\n    }\n  }, [gameState.lives, gameState.wave, gameState.score, towers, onAction]);\n\n  // Drawing functions\n  const drawPath = (ctx: CanvasRenderingContext2D) => {\n    ctx.strokeStyle = '#8B4513';\n    ctx.lineWidth = 30;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    \n    ctx.beginPath();\n    ctx.moveTo(gamePath[0].x, gamePath[0].y);\n    gamePath.slice(1).forEach(point => {\n      ctx.lineTo(point.x, point.y);\n    });\n    ctx.stroke();\n\n    // Path decorations\n    ctx.strokeStyle = '#DEB887';\n    ctx.lineWidth = 20;\n    ctx.beginPath();\n    ctx.moveTo(gamePath[0].x, gamePath[0].y);\n    gamePath.slice(1).forEach(point => {\n      ctx.lineTo(point.x, point.y);\n    });\n    ctx.stroke();\n  };\n\n  const drawTower = (ctx: CanvasRenderingContext2D, tower: Tower) => {\n    const config = towerTypes[tower.type];\n    \n    // Tower base\n    ctx.fillStyle = '#696969';\n    ctx.beginPath();\n    ctx.arc(tower.x, tower.y, 20, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Tower top\n    ctx.fillStyle = config.color;\n    ctx.beginPath();\n    ctx.arc(tower.x, tower.y, 15, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Tower details based on type\n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = '12px Arial';\n    ctx.textAlign = 'center';\n    \n    const symbols = { archer: '🏹', cannon: '💣', magic: '✨', ice: '❄️' };\n    ctx.fillText(symbols[tower.type], tower.x, tower.y + 4);\n\n    // Range indicator for selected tower type\n    if (gameState.selectedTowerType === tower.type) {\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\n      ctx.lineWidth = 2;\n      ctx.setLineDash([5, 5]);\n      ctx.beginPath();\n      ctx.arc(tower.x, tower.y, tower.range, 0, 2 * Math.PI);\n      ctx.stroke();\n      ctx.setLineDash([]);\n    }\n\n    // Kill count\n    if (tower.kills > 0) {\n      ctx.fillStyle = '#FFD700';\n      ctx.font = '10px Arial';\n      ctx.fillText(tower.kills.toString(), tower.x, tower.y - 25);\n    }\n  };\n\n  const drawEnemy = (ctx: CanvasRenderingContext2D, enemy: Enemy) => {\n    if (!enemy.alive) return;\n\n    const config = enemyTypes[enemy.type];\n    const size = { goblin: 12, orc: 16, troll: 20, dragon: 24 }[enemy.type];\n\n    // Enemy body\n    ctx.fillStyle = config.color;\n    ctx.beginPath();\n    ctx.arc(enemy.x, enemy.y, size, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Enemy details\n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'center';\n    \n    const symbols = { goblin: '👹', orc: '🗡️', troll: '🏔️', dragon: '🐉' };\n    ctx.fillText(symbols[enemy.type], enemy.x, enemy.y + 4);\n\n    // Health bar\n    const barWidth = size * 2;\n    const barHeight = 4;\n    const healthPercent = enemy.health / enemy.maxHealth;\n    \n    ctx.fillStyle = '#FF0000';\n    ctx.fillRect(enemy.x - barWidth/2, enemy.y - size - 10, barWidth, barHeight);\n    ctx.fillStyle = '#00FF00';\n    ctx.fillRect(enemy.x - barWidth/2, enemy.y - size - 10, barWidth * healthPercent, barHeight);\n  };\n\n  const drawProjectile = (ctx: CanvasRenderingContext2D, projectile: Projectile) => {\n    const colors = { archer: '#8B4513', cannon: '#000000', magic: '#9400D3', ice: '#00BFFF' };\n    \n    ctx.fillStyle = colors[projectile.type as keyof typeof colors];\n    ctx.beginPath();\n    ctx.arc(projectile.x, projectile.y, 4, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Trail effect\n    ctx.fillStyle = colors[projectile.type as keyof typeof colors] + '80';\n    ctx.beginPath();\n    ctx.arc(projectile.x - 2, projectile.y - 2, 2, 0, 2 * Math.PI);\n    ctx.fill();\n  };\n\n  const drawUI = (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement) => {\n    // Game stats panel\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n    ctx.fillRect(0, 0, canvas.width, 60);\n    \n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = '16px Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Wave: ${gameState.wave}`, 10, 25);\n    ctx.fillText(`Lives: ${gameState.lives}`, 10, 45);\n    ctx.fillText(`Gold: ${gameState.gold}`, 120, 25);\n    ctx.fillText(`Score: ${gameState.score}`, 120, 45);\n\n    // Tower selection panel\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n    ctx.fillRect(0, canvas.height - 80, canvas.width, 80);\n\n    const towerButtons = [\n      { type: 'archer', x: 50, key: '1' },\n      { type: 'cannon', x: 150, key: '2' },\n      { type: 'magic', x: 250, key: '3' },\n      { type: 'ice', x: 350, key: '4' }\n    ];\n\n    towerButtons.forEach(button => {\n      const config = towerTypes[button.type as keyof typeof towerTypes];\n      const isSelected = gameState.selectedTowerType === button.type;\n      const canAfford = gameState.gold >= config.cost;\n\n      // Button background\n      ctx.fillStyle = isSelected ? 'rgba(255, 255, 0, 0.5)' : \n                     canAfford ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 0, 0, 0.2)';\n      ctx.fillRect(button.x - 25, canvas.height - 70, 50, 60);\n\n      // Tower icon\n      ctx.fillStyle = config.color;\n      ctx.beginPath();\n      ctx.arc(button.x, canvas.height - 55, 12, 0, 2 * Math.PI);\n      ctx.fill();\n\n      // Tower info\n      ctx.fillStyle = canAfford ? '#FFFFFF' : '#FF6666';\n      ctx.font = '12px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(`${button.key}: $${config.cost}`, button.x, canvas.height - 20);\n      ctx.fillText(button.type.toUpperCase(), button.x, canvas.height - 8);\n    });\n\n    // Instructions\n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'right';\n    ctx.fillText('SPACE: Next Wave', canvas.width - 10, canvas.height - 45);\n    ctx.fillText('ESC: Cancel', canvas.width - 10, canvas.height - 25);\n    ctx.fillText('1-4: Select Tower', canvas.width - 10, canvas.height - 5);\n\n    // Wave progress\n    if (gameState.waveProgress > 0) {\n      ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';\n      ctx.font = '20px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText('WAVE IN PROGRESS', canvas.width / 2, 35);\n    }\n\n    // Game over screen\n    if (gameState.gameStatus === 'gameOver') {\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      \n      ctx.fillStyle = '#FF0000';\n      ctx.font = '32px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);\n      \n      ctx.fillStyle = '#FFFFFF';\n      ctx.font = '18px Arial';\n      ctx.fillText(`Final Wave: ${gameState.wave}`, canvas.width / 2, canvas.height / 2);\n      ctx.fillText(`Final Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 30);\n    }\n  };\n\n  const draw = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Clear canvas with background\n    ctx.fillStyle = '#1a4c2e';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Draw game elements\n    drawPath(ctx);\n    \n    towers.forEach(tower => drawTower(ctx, tower));\n    enemies.forEach(enemy => drawEnemy(ctx, enemy));\n    projectiles.forEach(proj => drawProjectile(ctx, proj));\n    \n    drawUI(ctx, canvas);\n\n    // Show placement preview\n    if (gameState.selectedTowerType && canvas) {\n      const rect = canvas.getBoundingClientRect();\n      // This would need mouse position tracking for preview\n    }\n  }, [towers, enemies, projectiles, gameState]);\n\n  // Game loop\n  useEffect(() => {\n    const gameLoop = () => {\n      updateEnemies();\n      updateTowers();\n      updateProjectiles();\n      draw();\n      setFrameCount(prev => prev + 1);\n      gameLoopRef.current = requestAnimationFrame(gameLoop);\n    };\n\n    gameLoopRef.current = requestAnimationFrame(gameLoop);\n\n    return () => {\n      if (gameLoopRef.current) {\n        cancelAnimationFrame(gameLoopRef.current);\n      }\n    };\n  }, [updateEnemies, updateTowers, updateProjectiles, draw]);\n\n  // Event listeners\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown);\n    \n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [handleKeyDown]);\n\n  return (\n    <div style={{ \n      display: 'flex', \n      flexDirection: 'column', \n      alignItems: 'center',\n      background: '#0f2419',\n      borderRadius: '12px',\n      padding: '16px',\n      border: '2px solid #2d5016',\n    }}>\n      <canvas\n        ref={canvasRef}\n        width={600}\n        height={400}\n        style={{\n          border: '2px solid #4a6741',\n          borderRadius: '8px',\n          background: '#1a4c2e',\n          cursor: gameState.selectedTowerType ? 'crosshair' : 'default',\n        }}\n        onClick={handleCanvasClick}\n        tabIndex={0}\n      />\n      \n      <div style={{\n        marginTop: '12px',\n        color: '#ffffff',\n        fontSize: '14px',\n        textAlign: 'center',\n        maxWidth: '600px',\n      }}>\n        <p>🏰 <strong>Tower Defense</strong> - 키보드 1-4로 타워 선택, 클릭으로 배치, Space로 웨이브 시작!</p>\n        <p>적들이 끝까지 가지 못하도록 타워를 배치해서 막아보세요!</p>\n      </div>\n    </div>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}